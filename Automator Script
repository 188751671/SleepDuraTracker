/usr/bin/python3 - <<'PYCODE'
import csv, re, subprocess
from datetime import datetime, time, timedelta
from pathlib import Path

# -------- CONFIG --------
WINDOW_START = time(23, 0)   # 23:00
WINDOW_END   = time(13, 0)   # 13:00 (next day)
MIN_DURATION_MIN = 240       # 4 hours
LAST_N_DAYS = 7
LOG_PATH = Path.home() / "Desktop" / "sleepDuras.csv"
PIPE_CMD = r'pmset -g log | grep -E "Display is turned (off|on)"'
# ------------------------

LINE_RE = re.compile(
    r'^(\d{4}-\d{2}-\d{2})\s+'
    r'(\d{2}:\d{2}:\d{2})\s+'
    r'([+\-]\d{4})\s+\S+\s+Display is turned (off|on)\s*$'
)

def run_cmd():
    p = subprocess.Popen(PIPE_CMD, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    out, err = p.communicate()
    if p.returncode not in (0, 1):
        raise RuntimeError(err.strip() or "Failed to run pmset/grep")
    return out

def parse_events(text):
    events=[]
    for line in text.splitlines():
        m=LINE_RE.match(line.strip())
        if m:
            d,t,off,state=m.groups()
            dt=datetime.strptime(f"{d} {t} {off}","%Y-%m-%d %H:%M:%S %z")
            events.append((dt,state))
    events.sort(key=lambda x:x[0])
    return events

def pair_off_on(events):
    last_off=None
    for dt,state in events:
        if state=="off":
            last_off=dt
        elif state=="on" and last_off and dt>last_off:
            yield last_off, dt
            last_off=None

# ---- night window helpers (bind each pair to ON's night) ----
def night_bounds_for_on(on_dt: datetime, start_t: time, end_t: time):
    local_on = on_dt.astimezone()
    d = local_on.date()
    if start_t <= end_t:
        # non-wrapping window (e.g., 01:00->13:00)
        night_start = datetime.combine(d, start_t, tzinfo=local_on.tzinfo)
        if local_on.time() < start_t:
            d_prev = d - timedelta(days=1)
            night_start = datetime.combine(d_prev, start_t, tzinfo=local_on.tzinfo)
        night_end = datetime.combine(night_start.date(), end_t, tzinfo=local_on.tzinfo)
        if night_end <= night_start:
            night_end += timedelta(days=1)
    else:
        # wrapping window (e.g., 23:00->13:00)
        night_end = datetime.combine(d, end_t, tzinfo=local_on.tzinfo)
        if local_on.time() >= end_t:
            night_end += timedelta(days=1)
        night_start = datetime.combine(night_end.date()-timedelta(days=1), start_t, tzinfo=local_on.tzinfo)
    return night_start, night_end

def pair_in_same_night(off_dt: datetime, on_dt: datetime, start_t: time, end_t: time) -> bool:
    night_start, night_end = night_bounds_for_on(on_dt, start_t, end_t)
    return (night_start <= off_dt <= on_dt <= night_end)

def hm_dot(mins:int)->str:
    return f"{mins//60}.{mins%60:02d}"

def ensure_csv_header(path: Path):
    if not path.exists():
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", newline="") as f:
            csv.writer(f).writerow(["date","duration_hm"])

def existing_dates(path: Path):
    s=set()
    if not path.exists(): return s
    with path.open("r", newline="") as f:
        r=csv.DictReader(f)
        for row in r:
            if row.get("date"): s.add(row["date"])
    return s

def main():
    now = datetime.now().astimezone()
    cutoff = now - timedelta(days=LAST_N_DAYS)

    events = parse_events(run_cmd())
    pairs = [(a,b) for a,b in pair_off_on(events) if b >= cutoff]

    # Keep ONLY the single longest qualifying segment per ON date
    longest_by_date = {}
    for off_dt, on_dt in pairs:
        if not pair_in_same_night(off_dt, on_dt, WINDOW_START, WINDOW_END):
            continue
        dur_min = int((on_dt - off_dt).total_seconds() // 60)
        if dur_min < MIN_DURATION_MIN:
            continue

        # Determine ON-date key (morning date)
        on_local = on_dt.astimezone()
        date_key = on_local.strftime("%Y-%m-%d")

        # Optional sanity: cap impossible durations to night length + small buffer
        n_start, n_end = night_bounds_for_on(on_dt, WINDOW_START, WINDOW_END)
        night_len_min = int((n_end - n_start).total_seconds() // 60)
        if dur_min > night_len_min + 30:
            continue

        if date_key not in longest_by_date or dur_min > longest_by_date[date_key]:
            longest_by_date[date_key] = dur_min

    ensure_csv_header(LOG_PATH)
    seen = existing_dates(LOG_PATH)
    rows = [[d, hm_dot(longest_by_date[d])] for d in sorted(longest_by_date) if d not in seen]

    if rows:
        with LOG_PATH.open("a", newline="") as f:
            csv.writer(f).writerows(rows)
        print(f"Appended {len(rows)} day(s) -> {LOG_PATH}")
    else:
        print("Nothing new to append.")

if __name__=="__main__":
    main()
PYCODE
